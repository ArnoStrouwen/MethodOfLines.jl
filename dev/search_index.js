var documenterSearchIndex = {"docs":
[{"location":"tutorials/brusselator/#brusselator","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/brusselator/#Using-the-Brusselator-PDE-as-an-example","page":"Tutorial","title":"Using the Brusselator PDE as an example","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The Brusselator PDE is defined as follows:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 vpartial x^2 + fracpartial^2 vpartial y^2)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"where","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelse\nendcases","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"and the initial conditions are","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x y 0) = 22cdot (y(1-y))^32 \nv(x y 0) = 27cdot (x(1-x))^32\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"with the periodic boundary condition","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"on a timespan of t in 0115.","category":"page"},{"location":"tutorials/brusselator/#Solving-with-MethodOfLines","page":"Tutorial","title":"Solving with MethodOfLines","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With ModelingToolkit.jl, we first symbolicaly define the system, see also the docs for (PDESystem)[https://mtk.sciml.ai/stable/systems/PDESystem/]:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\n∇²(u) = Dxx(u) + Dyy(u)\n\nbrusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = 1.0\nt_max = 11.5\n\nα = 10.\n\nu0(x,y,t) = 22(y*(1-y))^(3/2)\nv0(x,y,t) = 27(x*(1-x))^(3/2)\n\neq = [Dt(u(x,y,t)) ~ 1. + v(x,y,t)*u(x,y,t)^2 - 4.4*u(x,y,t) + α*∇²(u(x,y,t)) + brusselator_f(x, y, t),\n       Dt(v(x,y,t)) ~ 3.4*u(x,y,t) - v(x,y,t)*u(x,y,t)^2 + α*∇²(v(x,y,t))]\n\ndomains = [x ∈ Interval(x_min, x_max),\n              y ∈ Interval(y_min, y_max),\n              t ∈ Interval(t_min, t_max)]\n\n# Periodic BCs\nbcs = [u(x,y,0) ~ u0(x,y,0),\n       u(0,y,t) ~ u(1,y,t),\n       u(x,0,t) ~ u(x,1,t),\n\n       v(x,y,0) ~ v0(x,y,0),\n       v(0,y,t) ~ v(1,y,t),\n       v(x,0,t) ~ v(x,1,t)] \n\n@named pdesys = PDESystem(eq,bcs,domains,[x,y,t],[u(x,y,t),v(x,y,t)])","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For a list of limitations constraining which systems will work, see here","category":"page"},{"location":"tutorials/brusselator/#Method-of-lines-discretization","page":"Tutorial","title":"Method of lines discretization","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Then, we create the discretization, leaving the time dimension undiscretized by supplying t as an argument. Optionally, all dimensions can be discretized in this step, just remove the argument t and supply t=>dt in the dxs. See here for more information on the MOLFiniteDifference constructor arguments and options.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"N = 32\n\ndx = 1/N\ndy = 1/N\n\norder = 2\n\ndiscretization = MOLFiniteDifference([x=>dx, y=>dy], t, approx_order=order grid_type=center_align)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Next, we discretize the system, converting the PDESystem in to an ODEProblem or NonlinearProblem.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"# Convert the PDE problem into an ODE problem\nprintln(\"Discretization:\")\n@time prob = discretize(pdesys,discretization)","category":"page"},{"location":"tutorials/brusselator/#How-it-works","page":"Tutorial","title":"How it works","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, namely it's rule matching features to recognize terms which require particular discretizations.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Given your discretization and PDESystem, we take each independent variable defined on the space to be discretized and create a corresponding range. We then take each dependant variable and create an array of symbolic variables to represent it in its discretized form. ","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Next, the boundary conditions are discretized, creating an equation for each point on the boundary in terms of the discretized variables, replacing any space derivatives in the direction of the boundary with their upwind finite difference expressions.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"After that, the system of PDEs is discretized, first matching each PDE to each dependant variable by which variable is highest order in each PDE, with precedance given to time derivatives. Then, the PDEs are discretized creating a finite difference equation for each point in their matched dependant variables discrete form, less the number of boundary equations. These equations are removed from around the boundary, so each PDE only has discrete equations on its variable's interior.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Now we have a system of equations which are either ODEs, linear, or nonlinear equations and an equal number of unknowns. See (here)[] for the system that is generated for the Brusselator at low point count. The structure of the system is simplified with ModelingToolkit.structural_simplify, and then either an ODEProblem or NonlinearProblem is returned. Under the hood, the ODEProblem generates a fast semidiscretization, written in julia with RuntimeGeneratedFunctions. See (here)[] for an example of the generated code for the Brusselator system at low point count. ","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Now your problem can be solved with an appropriate ODE solver, or Nonlinear solver if you have not supplied a time dimension in the MOLFiniteDifference constructor. Include these solvers with using OrdinaryDiffEq or using NonlinearSolve, then call sol = solve(prob, AppropriateSolver()) or sol = NonlinearSolve.solve(prob, AppropriateSolver()). For more information on the available solvers, see the docs for (DifferentialEquations.jl)[https://diffeq.sciml.ai/stable/solvers/ode_solve/] and (NonlinearSolve.jl)[http://nonlinearsolve.sciml.ai/dev/solvers/NonlinearSystemSolvers/].","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"println(\"Solve:\")\n@time sol = solve(prob, TRBDF2(), saveat=0.1)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"To retrieve your solution, for example for u, use sol[u]. To get the time axis, use sol.t.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"To get the generated code for your system, use code = ODEFunctionExpr(prob), or MethodOfLines.generate_code(pdesys, discretization, \"my_generated_code_filename.jl\"), which will create a file called my_generated_code_filename.jl in pwd(). This can be useful to find errors in the discretization, but note that it is not recommended to use this code directly, calling solve(prob, AppropriateSolver()) will handle this for you.","category":"page"},{"location":"MOLFiniteDifference/#[Discretization]('ref-molfd)","page":"MOLFiniteDifference","title":"Discretization","text":"","category":"section"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"struct MOLFiniteDifference{G} <: DiffEqBase.AbstractDiscretization\n    dxs\n    time\n    approx_order::Int\n    upwind_order::Int\n    grid_align::G\nend\n\n# Constructors. If no order is specified, both upwind and centered differences will be 2nd order\nfunction MOLFiniteDifference(dxs, time=nothing; approx_order = 2, upwind_order = 1, grid_align=CenterAlignedGrid())\n    \n    if approx_order % 2 != 0\n        @warn \"Discretization approx_order must be even, rounding up to $(approx_order+1)\"\n    end\n    @assert approx_order >= 1 \"approx_order must be at least 1\"\n    @assert upwind_order >= 1 \"upwind_order must be at least 1\"\n    \n    return MOLFiniteDifference{typeof(grid_align)}(dxs, time, approx_order, upwind_order, grid_align)\nend","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"eq = [your system of equations, see examples for possibilities]\nbcs = [your boundary conditions, see examples for possibilities]\n\ndomain = [your domain, a vector of Intervals i.e. x ∈ Interval(x_min, x_max)]\n\n@named pdesys = PDESystem(eq, bcs, domains, [t, x, y], [u(t, x, y)])\n\ndiscretization = MOLFiniteDifference(dxs, \n                                      <your choice of continuous variable, usually time>; \n                                      upwind_order = <Currently unstable at any value other than 1>, \n                                      approx_order = <Order of derivative approximation, starting from 2> \n                                      grid_align = <your grid type choice>)\nprob = discretize(pdesys, discretization)","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Where dxs is a vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1]","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Note that the second argument to MOLFiniteDifference is optional, all parameters can be discretized if all required boundary conditions are specified.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Currently supported grid types: center_align and edge_align. Edge align will give better accuracy with Neumann Boundary conditions.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"center_align: naive grid, starting from lower boundary, ending on upper boundary with step of dx","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"edge_align: offset grid, set halfway between the points that would be generated with center_align, with extra points at either end that are above and below the supremum and infimum by dx/2. This improves accuracy for neumann BCs.","category":"page"},{"location":"#index","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"MethodOfLines.jl is a package for automated finite difference discretization of symbolicaly-defined PDEs in N dimensions.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"It uses symbolic expressions for systems of partial differential equations as defined with ModelingToolkit.jl, and Interval from DomainSets.jl to define the space(time) over which the simulation runs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"The package's handling is quite general, it is recommended to try out your system of equations and post an issue if you run in to trouble. If you want to solve it, we want to support it.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"See here for a full tutorial, involving the brusselator equation.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Allowable terms in the system include, but are not limited to","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Advection\nDiffusion\nReaction\nNonlinear Diffusion\nSpherical laplacian\nAny julia function of the symbolic parameters/dependant variables and other parameters in the environment that's defined on the whole domain.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Boundary conditions include, but are not limited to:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Dirichlet\nNeumann (can also include time derivative)\nRobin (can also include time derivative)\nPeriodic\nAny function, subject to the assumptions below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"At the moment the centered difference, upwind difference, nonlinear laplacian and spherical laplacian schemes are implemented. If you know of a scheme with better stability or accuracy in any specific case, please post an issue with a link to a paper.","category":"page"},{"location":"#limitations","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"Known Limitations","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"At the moment the package is able to discretize almost any system, with some assumptions listed below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"That the grid is cartesian.\nThat the equation is first order in time.\nIntergral equations are not supported.\nThat dependant variables always have the same argument signature, except in BCs.\nThat periodic boundary conditions are of the simple form u(t, x_min) ~ u(t, x_max), or the same with lhs and rhs reversed. Note that this generalises to higher dimensions.\nThat boundary conditions do not contain references to derivatives which are not in the direction of the boundary, except in time.\nThat initial conditions are of the form u(...) ~ ..., and don't reference the initial time derivative.\nThat simple derivative terms are purely of a dependant variable, for example Dx(u(t,x,y)) is allowed but Dx(u(t,x,y)*v(t,x,y)), Dx(u(t,x)+1) or Dx(f(u(t,x))) are not. As a workaround please expand such terms with the product/chain rules and use the linearity of the derivative operator, or define a new dependant variable by adding an equation for it like eqs = [Differential(x)(w(t,x))~ ... , w(t,x) ~ v(t,x)*u(t,x)]. An exception to this is if the differential is a nonlinear or spherical laplacian, in which case only the innermost argument should be wrapped.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"If any of these limitations are a problem for you please post an issue and we will prioritize removing them. If you discover a limitation that isn't listed here, pleae post an issue with example code.","category":"page"},{"location":"#If-you-have-any-usage-questions-or-feature-requests,-please-post-an-issue","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"If you have any usage questions or feature requests, please post an issue","text":"","category":"section"},{"location":"boundary_conditions/#[Boundary-Conditions](@ref-bcs)","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"What follows is a set of allowable boundary conditions, please note that this is not exhaustive - Try your condition and see if it works, the handling is quite general. If it doesn't please post an issue and we'll try to support it. At the moment boundary conditions have to be supplied at the edge of the domain, but there are plans to support conditions embedded in the domain.","category":"page"},{"location":"boundary_conditions/#Definitions","page":"Boundary Conditions","title":"Definitions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using ModelingToolkit, MethodOfLines, Domainsets\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\nx_min = y_min = 0.0\n\nx_max = y_max = 1.0","category":"page"},{"location":"boundary_conditions/#Dirichlet","page":"Boundary Conditions","title":"Dirichlet","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, 0, y) ~ 1.0","category":"page"},{"location":"boundary_conditions/#Time-dependant","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, 0., y) ~ x_min*y+ 0.5t","category":"page"},{"location":"boundary_conditions/#Julia-function","page":"Boundary Conditions","title":"Julia function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, y_max) ~ sin(x)","category":"page"},{"location":"boundary_conditions/#User-defined-function","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # Note that symbolic conditionals require the use of IfElse.ifelse\n    return IfElse.ifelse(z > 0, x, 0.0)\nend\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Neumann/Robin","page":"Boundary Conditions","title":"Neumann/Robin","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x_min, y) ~ 2. * Dx(v(t, x_min, y))","category":"page"},{"location":"boundary_conditions/#Time-dependant-2","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ x_min*Dy(v(t,x_min,y)) + 0.5t","category":"page"},{"location":"boundary_conditions/#Higher-order","page":"Boundary Conditions","title":"Higher order","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, 1.0) ~ sin(x) + Dyy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Time-derivative","page":"Boundary Conditions","title":"Time derivative","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Dt(u(t, x_min, y)) ~ 0.2","category":"page"},{"location":"boundary_conditions/#User-defined-function-2","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"function f(u, v)\n    (u + Dyy(v) - Dy(u))/(1 + v)\nend\n\nDyy(u(t, x, y_min)) ~ f(u(t, x, y_min), v(t, x, y_min)) + 1","category":"page"},{"location":"boundary_conditions/#lhs","page":"Boundary Conditions","title":"0 lhs","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"0 ~ u(t, x, y_max) - Dy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Periodic","page":"Boundary Conditions","title":"Periodic","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ u(t, x_max, y)\n\nv(t, x, y_max) ~ u(t, x_max, y)","category":"page"}]
}
