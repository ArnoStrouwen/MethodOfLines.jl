var documenterSearchIndex = {"docs":
[{"location":"generated/bruss_ode_eqs/#brusssys","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"Here's the generated system of equations for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-u","page":"Generated ODE system for the Brusselator Equation","title":"Equations for u","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(u[2, 2](t)) ~ 1.0 + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[2, 2](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 2](t) + (u[2, 2](t)^2)*v[2, 2](t) - 4.4u[2, 2](t), \nDifferential(t)(u[3, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[3, 2](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 2](t) + (u[3, 2](t)^2)*v[3, 2](t) - 4.4u[3, 2](t), \nDifferential(t)(u[4, 2](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 2](t) + 160.0u[3, 2](t) + 160.0u[5, 2](t) - 320.0u[4, 2](t) + (u[4, 2](t)^2)*v[4, 2](t) - 4.4u[4, 2](t), \nDifferential(t)(u[5, 2](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[4, 2](t) - 320.0u[5, 2](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 2](t) + (u[5, 2](t)^2)*v[5, 2](t) - 4.4u[5, 2](t), \nDifferential(t)(u[2, 3](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 3](t) + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[2, 3](t) + (u[2, 3](t)^2)*v[2, 3](t) - 4.4u[2, 3](t), \nDifferential(t)(u[3, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[3, 3](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 3](t) + (u[3, 3](t)^2)*v[3, 3](t) - 4.4u[3, 3](t), \nDifferential(t)(u[4, 3](t)) ~ 1.0 + 160.0u[3, 3](t) + 160.0u[5, 3](t) - 320.0u[4, 3](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 3](t) + (u[4, 3](t)^2)*v[4, 3](t) - 4.4u[4, 3](t), \nDifferential(t)(u[5, 3](t)) ~ 1.0 + 160.0u[2, 3](t) + 160.0u[4, 3](t) - 320.0u[5, 3](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 3](t) + (u[5, 3](t)^2)*v[5, 3](t) - 4.4u[5, 3](t), \nDifferential(t)(u[2, 4](t)) ~ 1.0 + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[2, 4](t) + 160.0u[2, 3](t) + 160.0u[2, 5](t) - 320.0u[2, 4](t) + (u[2, 4](t)^2)*v[2, 4](t) - 4.4u[2, 4](t), \nDifferential(t)(u[3, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[3, 4](t) + 160.0u[3, 3](t) + 160.0u[3, 5](t) - 320.0u[3, 4](t) + (u[3, 4](t)^2)*v[3, 4](t) - 4.4u[3, 4](t), \nDifferential(t)(u[4, 4](t)) ~ 1.0 + 160.0u[4, 3](t) + 160.0u[4, 5](t) - 320.0u[4, 4](t) + 160.0u[3, 4](t) + 160.0u[5, 4](t) - 320.0u[4, 4](t) + (u[4, 4](t)^2)*v[4, 4](t) - 4.4u[4, 4](t), \nDifferential(t)(u[5, 4](t)) ~ 1.0 + 160.0u[2, 4](t) + 160.0u[4, 4](t) - 320.0u[5, 4](t) + 160.0u[5, 3](t) + 160.0u[5, 5](t) - 320.0u[5, 4](t) + (u[5, 4](t)^2)*v[5, 4](t) - 4.4u[5, 4](t), \nDifferential(t)(u[2, 5](t)) ~ 1.0 + 160.0u[2, 2](t) + 160.0u[2, 4](t) - 320.0u[2, 5](t) + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[2, 5](t) + (u[2, 5](t)^2)*v[2, 5](t) - 4.4u[2, 5](t), \nDifferential(t)(u[3, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[3, 5](t) + 160.0u[3, 2](t) + 160.0u[3, 4](t) - 320.0u[3, 5](t) + (u[3, 5](t)^2)*v[3, 5](t) - 4.4u[3, 5](t), \nDifferential(t)(u[4, 5](t)) ~ 1.0 + 160.0u[3, 5](t) + 160.0u[5, 5](t) - 320.0u[4, 5](t) + 160.0u[4, 2](t) + 160.0u[4, 4](t) - 320.0u[4, 5](t) + (u[4, 5](t)^2)*v[4, 5](t) - 4.4u[4, 5](t), \nDifferential(t)(u[5, 5](t)) ~ 1.0 + 160.0u[2, 5](t) + 160.0u[4, 5](t) - 320.0u[5, 5](t) + 160.0u[5, 2](t) + 160.0u[5, 4](t) - 320.0u[5, 5](t) + (u[5, 5](t)^2)*v[5, 5](t) - 4.4u[5, 5](t)] ","category":"page"},{"location":"generated/bruss_ode_eqs/#Equations-for-v","page":"Generated ODE system for the Brusselator Equation","title":"Equations for v","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"[Differential(t)(v[2, 2](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 2](t) + 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[2, 2](t) + 3.4u[2, 2](t) - (u[2, 2](t)^2)*v[2, 2](t), \nDifferential(t)(v[3, 2](t)) ~ 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[3, 2](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 2](t) + 3.4u[3, 2](t) - (u[3, 2](t)^2)*v[3, 2](t), \nDifferential(t)(v[4, 2](t)) ~ 160.0v[3, 2](t) + 160.0v[5, 2](t) - 320.0v[4, 2](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 2](t) + 3.4u[4, 2](t) - (u[4, 2](t)^2)*v[4, 2](t), \nDifferential(t)(v[5, 2](t)) ~ 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 2](t) + 160.0v[2, 2](t) + 160.0v[4, 2](t) - 320.0v[5, 2](t) + 3.4u[5, 2](t) - (u[5, 2](t)^2)*v[5, 2](t), \nDifferential(t)(v[2, 3](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 3](t) + 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[2, 3](t) + 3.4u[2, 3](t) - (u[2, 3](t)^2)*v[2, 3](t), \nDifferential(t)(v[3, 3](t)) ~ 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 3](t) + 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[3, 3](t) + 3.4u[3, 3](t) - (u[3, 3](t)^2)*v[3, 3](t), \nDifferential(t)(v[4, 3](t)) ~ 160.0v[3, 3](t) + 160.0v[5, 3](t) - 320.0v[4, 3](t) + 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 3](t) + 3.4u[4, 3](t) - (u[4, 3](t)^2)*v[4, 3](t), \nDifferential(t)(v[5, 3](t)) ~ 160.0v[2, 3](t) + 160.0v[4, 3](t) - 320.0v[5, 3](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 3](t) + 3.4u[5, 3](t) - (u[5, 3](t)^2)*v[5, 3](t), \nDifferential(t)(v[2, 4](t)) ~ 160.0v[2, 3](t) + 160.0v[2, 5](t) - 320.0v[2, 4](t) + 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[2, 4](t) + 3.4u[2, 4](t) - (u[2, 4](t)^2)*v[2, 4](t), \nDifferential(t)(v[3, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[3, 4](t) + 160.0v[3, 3](t) + 160.0v[3, 5](t) - 320.0v[3, 4](t) + 3.4u[3, 4](t) - (u[3, 4](t)^2)*v[3, 4](t), \nDifferential(t)(v[4, 4](t)) ~ 160.0v[3, 4](t) + 160.0v[5, 4](t) - 320.0v[4, 4](t) + 160.0v[4, 3](t) + 160.0v[4, 5](t) - 320.0v[4, 4](t) + 3.4u[4, 4](t) - (u[4, 4](t)^2)*v[4, 4](t), \nDifferential(t)(v[5, 4](t)) ~ 160.0v[2, 4](t) + 160.0v[4, 4](t) - 320.0v[5, 4](t) + 160.0v[5, 3](t) + 160.0v[5, 5](t) - 320.0v[5, 4](t) + 3.4u[5, 4](t) - (u[5, 4](t)^2)*v[5, 4](t), \nDifferential(t)(v[2, 5](t)) ~ 160.0v[2, 2](t) + 160.0v[2, 4](t) - 320.0v[2, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[2, 5](t) + 3.4u[2, 5](t) - (u[2, 5](t)^2)*v[2, 5](t), \nDifferential(t)(v[3, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[3, 5](t) + 160.0v[3, 2](t) + 160.0v[3, 4](t) - 320.0v[3, 5](t) + 3.4u[3, 5](t) - (u[3, 5](t)^2)*v[3, 5](t), \nDifferential(t)(v[4, 5](t)) ~ 160.0v[4, 2](t) + 160.0v[4, 4](t) - 320.0v[4, 5](t) + 160.0v[3, 5](t) + 160.0v[5, 5](t) - 320.0v[4, 5](t) + 3.4u[4, 5](t) - (u[4, 5](t)^2)*v[4, 5](t), \nDifferential(t)(v[5, 5](t)) ~ 160.0v[2, 5](t) + 160.0v[4, 5](t) - 320.0v[5, 5](t) + 160.0v[5, 2](t) + 160.0v[5, 4](t) - 320.0v[5, 5](t) + 3.4u[5, 5](t) - (u[5, 5](t)^2)*v[5, 5](t)]","category":"page"},{"location":"generated/bruss_ode_eqs/#Boundary-condition-Equations","page":"Generated ODE system for the Brusselator Equation","title":"Boundary condition Equations","text":"","category":"section"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"u[2, 1](t) ~ u[2, 5](t), \nu[3, 1](t) ~ u[3, 5](t), \nu[4, 1](t) ~ u[4, 5](t), \nu[5, 1](t) ~ u[5, 5](t), \nu[1, 2](t) ~ u[5, 2](t), \nu[1, 3](t) ~ u[5, 3](t), \nu[1, 4](t) ~ u[5, 4](t), \nu[1, 5](t) ~ u[5, 5](t), \nu[1, 1](t) ~ 0, # Invalid corner point set to 0\nv[2, 1](t) ~ v[2, 5](t), \nv[3, 1](t) ~ v[3, 5](t), \nv[4, 1](t) ~ v[4, 5](t), \nv[5, 1](t) ~ v[5, 5](t), \nv[1, 2](t) ~ v[5, 2](t), \nv[1, 3](t) ~ v[5, 3](t), \nv[1, 4](t) ~ v[5, 4](t), \nv[1, 5](t) ~ v[5, 5](t), \nv[1, 1](t) ~ 0] # Invalid corner point set to 0","category":"page"},{"location":"generated/bruss_ode_eqs/","page":"Generated ODE system for the Brusselator Equation","title":"Generated ODE system for the Brusselator Equation","text":"On the call to ODEProblem, this code is generated.","category":"page"},{"location":"MOLFiniteDifference/#molfd","page":"MOLFiniteDifference","title":"Discretization","text":"","category":"section"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"struct MOLFiniteDifference{G} <: DiffEqBase.AbstractDiscretization\n    dxs\n    time\n    approx_order::Int\n    upwind_order::Int\n    grid_align::G\nend\n\n# Constructors. If no order is specified, both upwind and centered differences will be 2nd order\nfunction MOLFiniteDifference(dxs, time=nothing; approx_order = 2, upwind_order = 1, grid_align=CenterAlignedGrid())\n    \n    if approx_order % 2 != 0\n        @warn \"Discretization approx_order must be even, rounding up to $(approx_order+1)\"\n    end\n    @assert approx_order >= 1 \"approx_order must be at least 1\"\n    @assert upwind_order >= 1 \"upwind_order must be at least 1\"\n    \n    return MOLFiniteDifference{typeof(grid_align)}(dxs, time, approx_order, upwind_order, grid_align)\nend","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"eq = [your system of equations, see examples for possibilities]\nbcs = [your boundary conditions, see examples for possibilities]\n\ndomain = [your domain, a vector of Intervals i.e. x ∈ Interval(x_min, x_max)]\n\n@named pdesys = PDESystem(eq, bcs, domains, [t, x, y], [u(t, x, y)])\n\ndiscretization = MOLFiniteDifference(dxs, \n                                      <your choice of continuous variable, usually time>; \n                                      upwind_order = <Currently unstable at any value other than 1>, \n                                      approx_order = <Order of derivative approximation, starting from 2> \n                                      grid_align = <your grid type choice>)\nprob = discretize(pdesys, discretization)","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Where dxs is a vector of pairs of parameters to the grid step in this dimension, i.e. [x=>0.2, y=>0.1]","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Note that the second argument to MOLFiniteDifference is optional, all parameters can be discretized if all required boundary conditions are specified.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"Currently supported grid types: center_align and edge_align. Edge align will give better accuracy with Neumann boundary conditions.","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"center_align: naive grid, starting from lower boundary, ending on upper boundary with step of dx","category":"page"},{"location":"MOLFiniteDifference/","page":"MOLFiniteDifference","title":"MOLFiniteDifference","text":"edge_align: offset grid, set halfway between the points that would be generated with center_align, with extra points at either end that are above and below the supremum and infimum by dx/2. This improves accuracy for Neumann BCs.","category":"page"},{"location":"tutorials/brusselator/#brusselator","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/brusselator/#Using-the-Brusselator-PDE-as-an-example","page":"Tutorial","title":"Using the Brusselator PDE as an example","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The Brusselator PDE is defined as follows:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 vpartial x^2 + fracpartial^2 vpartial y^2)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"where","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"f(x y t) = begincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelse\nendcases","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"and the initial conditions are","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x y 0) = 22cdot (y(1-y))^32 \nv(x y 0) = 27cdot (x(1-x))^32\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"with the periodic boundary condition","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"beginalign\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)\nendalign","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"on a timespan of t in 0115.","category":"page"},{"location":"tutorials/brusselator/#Solving-with-MethodOfLines","page":"Tutorial","title":"Solving with MethodOfLines","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With ModelingToolkit.jl, we first symbolicaly define the system, see also the docs for PDESystem:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"using ModelingToolkit, MethodOfLines, OrdinaryDiffEq, DomainSets\n\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\n∇²(u) = Dxx(u) + Dyy(u)\n\nbrusselator_f(x, y, t) = (((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) * (t >= 1.1) * 5.\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = 1.0\nt_max = 11.5\n\nα = 10.\n\nu0(x,y,t) = 22(y*(1-y))^(3/2)\nv0(x,y,t) = 27(x*(1-x))^(3/2)\n\neq = [Dt(u(x,y,t)) ~ 1. + v(x,y,t)*u(x,y,t)^2 - 4.4*u(x,y,t) + α*∇²(u(x,y,t)) + brusselator_f(x, y, t),\n       Dt(v(x,y,t)) ~ 3.4*u(x,y,t) - v(x,y,t)*u(x,y,t)^2 + α*∇²(v(x,y,t))]\n\ndomains = [x ∈ Interval(x_min, x_max),\n              y ∈ Interval(y_min, y_max),\n              t ∈ Interval(t_min, t_max)]\n\n# Periodic BCs\nbcs = [u(x,y,0) ~ u0(x,y,0),\n       u(0,y,t) ~ u(1,y,t),\n       u(x,0,t) ~ u(x,1,t),\n\n       v(x,y,0) ~ v0(x,y,0),\n       v(0,y,t) ~ v(1,y,t),\n       v(x,0,t) ~ v(x,1,t)] \n\n@named pdesys = PDESystem(eq,bcs,domains,[x,y,t],[u(x,y,t),v(x,y,t)])","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For a list of limitations constraining which systems will work, see here","category":"page"},{"location":"tutorials/brusselator/#Method-of-lines-discretization","page":"Tutorial","title":"Method of lines discretization","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Then, we create the discretization, leaving the time dimension undiscretized by supplying t as an argument. Optionally, all dimensions can be discretized in this step, just remove the argument t and supply t=>dt in the dxs. See here for more information on the MOLFiniteDifference constructor arguments and options.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"N = 32\n\ndx = 1/N\ndy = 1/N\n\norder = 2\n\ndiscretization = MOLFiniteDifference([x=>dx, y=>dy], t, approx_order=order, grid_align=center_align)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Next, we discretize the system, converting the PDESystem in to an ODEProblem or NonlinearProblem.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"# Convert the PDE problem into an ODE problem\nprintln(\"Discretization:\")\n@time prob = discretize(pdesys,discretization)","category":"page"},{"location":"tutorials/brusselator/#Solving-the-problem","page":"Tutorial","title":"Solving the problem","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Now your problem can be solved with an appropriate ODE solver, or Nonlinear solver if you have not supplied a time dimension in the MOLFiniteDifference constructor. Include these solvers with using OrdinaryDiffEq or using NonlinearSolve, then call sol = solve(prob, AppropriateSolver()) or sol = NonlinearSolve.solve(prob, AppropriateSolver()). For more information on the available solvers, see the docs for DifferentialEquations.jl and NonlinearSolve.jl.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"println(\"Solve:\")\n@time sol = solve(prob, TRBDF2(), saveat=0.1)","category":"page"},{"location":"tutorials/brusselator/#Extracting-results","page":"Tutorial","title":"Extracting results","text":"","category":"section"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"To retrieve your solution, for example for u, use sol[u]. To get the time axis, use sol.t.","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"Due to current limitations in the sol interface, above 1 discretized dimension the result must be manually reshaped to correctly display the result, here is an example of how to do this:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With grid_align = center_align:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"discrete_x = x_min:dx:x_max\ndiscrete_y = y_min:dy:y_max\n\nNx = floor(Int64, (x_max - x_min) / dx) + 1\nNy = floor(Int64, (y_max - y_min) / dy) + 1\n\n@variables u[1:Nx,1:Ny](t)\n@variables v[1:Nx,1:Ny](t)\n\nsolu, solv = map(1:length(sol.t)) do k\n       solu = reshape([sol[u[(i-1)*Ny+j]][k] for i in 1:Nx for j in 1:Ny],(Nx,Ny))\n       solv = reshape([sol[v[(i-1)*Ny+j]][k] for i in 1:Nx for j in 1:Ny],(Nx,Ny))\n       (solu, solv)\nend","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"With grid_align = edge_align:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"discrete_x = x_min - dx/2 : dx : x_max + dx/2\ndiscrete_y = y_min - dy/2 : dy : y_max + dy/2\n\nNx = floor(Int64, (x_max - x_min) / dx) + 2\nNy = floor(Int64, (y_max - y_min) / dy) + 2\n\n@variables u[1:Nx,1:Ny](t)\n@variables v[1:Nx,1:Ny](t)\n\nsolu, solv = map(1:length(sol.t)) do k\n       solu = reshape([sol[u[(i-1)*Ny+j]][k] for i in 1:Nx for j in 1:Ny],(Nx,Ny))\n       solv = reshape([sol[v[(i-1)*Ny+j]][k] for i in 1:Nx for j in 1:Ny],(Nx,Ny))\n       (solu, solv)\nend","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"The result after plotting an animation:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For u:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"anim = @animate for k in 1:length(t)\n    heatmap(solu[k][2:end, 2:end], title=\"$(t[k])\")\nend\ngif(anim, \"plots/Brusselator2Dsol_u.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_u)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"For v:","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"anim = @animate for k in 1:length(t)\n    heatmap(solv[k][2:end, 2:end], title=\"$(t[k])\")\nend\ngif(anim, \"plots/Brusselator2Dsol_v.gif\", fps = 8)","category":"page"},{"location":"tutorials/brusselator/","page":"Tutorial","title":"Tutorial","text":"(Image: Brusselator2Dsol_v)","category":"page"},{"location":"tutorials/icbc_sampled/#Initial-and-Boundary-Conditions-with-sampled/measured-Data","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"","category":"section"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Initial and boundary conditions are sometimes applied with measured data that is itself pre-discretized. In order to use such data it is recommended to leverage Interpolations.jl, or DataInterpolations.jl, for better dealing with possibly noisy data (currently limited to 1D). To create a callable effectively continuous function, for example (from the Interpolations.jl docs):","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"1D:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"A_x = 1.:2.:40.\nA = [log(x) for x in A_x]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp1 = scale(itp, A_x)\nsitp1(3.) # exactly log(3.)\nsitp1(3.5) # approximately log(3.5)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Multidimensional:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"A_x1 = 1:.1:10\nA_x2 = 1:.5:20\nf(x1, x2) = log(x1+x2)\nA = [f(x1,x2) for x1 in A_x1, x2 in A_x2]\nitp = interpolate(A, BSpline(Cubic(Line(OnGrid()))))\nsitp2 = scale(itp, A_x1, A_x2)\nsitp2(5., 10.) # exactly log(5 + 10)\nsitp2(5.6, 7.1) # approximately log(5.6 + 7.1)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then, register the functions with ModelingToolkit:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"@register sitp1(y)\n@register sitp2(x, y)","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Then as a BC or IC:","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"bcs = [u(0, x, y) ~ sitp2(x, y),\n       u(t, 0, y) ~ sitp1(y),\n       ...\n       ]","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"Note that the measured data need not be measured on the same grid as will be generated for the discretization in MethodOfLines.jl, as long as it is defined upon the whole simulation domain it will be automatically re-sampled.","category":"page"},{"location":"tutorials/icbc_sampled/","page":"Initial and Boundary Conditions with sampled/measured Data","title":"Initial and Boundary Conditions with sampled/measured Data","text":"If you are using an edge_align grid, your interpolation will need to be defined ±dx/2 above and below the edges of the simulation domain where dx is the step size in the direction of that edge. Extrapolation may prove useful here.","category":"page"},{"location":"generated/bruss_code/#brusscode","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"","category":"section"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"Here's the generated julia code for the Brusselator, with dx = dy = 1/4","category":"page"},{"location":"generated/bruss_code/","page":"Generated Code for the Brusselator Equation","title":"Generated Code for the Brusselator Equation","text":"begin\n    var\"##f#260\" = (ModelingToolkit.ODEFunctionClosure)(function (ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        (SymbolicUtils.Code.create_array)(typeof(ˍ₋arg1), nothing, Val{1}(), Val{(32,)}(), (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\")), (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\")))\n                    end\n                end\n            end, function (ˍ₋out, ˍ₋arg1, ˍ₋arg2, t)\n                begin\n                    var\"u[2, 2](t)\" = @inbounds(ˍ₋arg1[1])\n                    var\"u[3, 2](t)\" = @inbounds(ˍ₋arg1[2])\n                    var\"u[4, 2](t)\" = @inbounds(ˍ₋arg1[3])\n                    var\"u[5, 2](t)\" = @inbounds(ˍ₋arg1[4])\n                    var\"u[2, 3](t)\" = @inbounds(ˍ₋arg1[5])\n                    var\"u[3, 3](t)\" = @inbounds(ˍ₋arg1[6])\n                    var\"u[4, 3](t)\" = @inbounds(ˍ₋arg1[7])\n                    var\"u[5, 3](t)\" = @inbounds(ˍ₋arg1[8])\n                    var\"u[2, 4](t)\" = @inbounds(ˍ₋arg1[9])\n                    var\"u[3, 4](t)\" = @inbounds(ˍ₋arg1[10])\n                    var\"u[4, 4](t)\" = @inbounds(ˍ₋arg1[11])\n                    var\"u[5, 4](t)\" = @inbounds(ˍ₋arg1[12])\n                    var\"u[2, 5](t)\" = @inbounds(ˍ₋arg1[13])\n                    var\"u[3, 5](t)\" = @inbounds(ˍ₋arg1[14])\n                    var\"u[4, 5](t)\" = @inbounds(ˍ₋arg1[15])\n                    var\"u[5, 5](t)\" = @inbounds(ˍ₋arg1[16])\n                    var\"v[2, 2](t)\" = @inbounds(ˍ₋arg1[17])\n                    var\"v[3, 2](t)\" = @inbounds(ˍ₋arg1[18])\n                    var\"v[4, 2](t)\" = @inbounds(ˍ₋arg1[19])\n                    var\"v[5, 2](t)\" = @inbounds(ˍ₋arg1[20])\n                    var\"v[2, 3](t)\" = @inbounds(ˍ₋arg1[21])\n                    var\"v[3, 3](t)\" = @inbounds(ˍ₋arg1[22])\n                    var\"v[4, 3](t)\" = @inbounds(ˍ₋arg1[23])\n                    var\"v[5, 3](t)\" = @inbounds(ˍ₋arg1[24])\n                    var\"v[2, 4](t)\" = @inbounds(ˍ₋arg1[25])\n                    var\"v[3, 4](t)\" = @inbounds(ˍ₋arg1[26])\n                    var\"v[4, 4](t)\" = @inbounds(ˍ₋arg1[27])\n                    var\"v[5, 4](t)\" = @inbounds(ˍ₋arg1[28])\n                    var\"v[2, 5](t)\" = @inbounds(ˍ₋arg1[29])\n                    var\"v[3, 5](t)\" = @inbounds(ˍ₋arg1[30])\n                    var\"v[4, 5](t)\" = @inbounds(ˍ₋arg1[31])\n                    var\"v[5, 5](t)\" = @inbounds(ˍ₋arg1[32])\n                    begin\n                        @inbounds begin\n                                ˍ₋out[1] = (+)((+)((+)((+)((+)((+)(1.0, (*)(-644.4, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)((^)(var\"u[2, 2](t)\", 2), var\"v[2, 2](t)\"))\n                                ˍ₋out[2] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)((^)(var\"u[3, 2](t)\", 2), var\"v[3, 2](t)\"))\n                                ˍ₋out[3] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[4, 2](t)\")), (*)((^)(var\"u[4, 2](t)\", 2), var\"v[4, 2](t)\"))\n                                ˍ₋out[4] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 2](t)\")), (*)((^)(var\"u[5, 2](t)\", 2), var\"v[5, 2](t)\"))\n                                ˍ₋out[5] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(-644.4, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[2, 3](t)\", 2), var\"v[2, 3](t)\"))\n                                ˍ₋out[6] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[3, 3](t)\")), (*)((^)(var\"u[3, 3](t)\", 2), var\"v[3, 3](t)\"))\n                                ˍ₋out[7] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 3](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(-644.4, var\"u[4, 3](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)((^)(var\"u[4, 3](t)\", 2), var\"v[4, 3](t)\"))\n                                ˍ₋out[8] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(-644.4, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 3](t)\", 2), var\"v[5, 3](t)\"))\n                                ˍ₋out[9] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 3](t)\")), (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[2, 4](t)\")), (*)((^)(var\"u[2, 4](t)\", 2), var\"v[2, 4](t)\"))\n                                ˍ₋out[10] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[3, 3](t)\")), (*)(-644.4, var\"u[3, 4](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)((^)(var\"u[3, 4](t)\", 2), var\"v[3, 4](t)\"))\n                                ˍ₋out[11] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 3](t)\")), (*)(-644.4, var\"u[4, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)((^)(var\"u[4, 4](t)\", 2), var\"v[4, 4](t)\"))\n                                ˍ₋out[12] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 4](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(160.0, var\"u[5, 3](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)(-644.4, var\"u[5, 4](t)\")), (*)((^)(var\"u[5, 4](t)\", 2), var\"v[5, 4](t)\"))\n                                ˍ₋out[13] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 2](t)\")), (*)(160.0, var\"u[2, 4](t)\")), (*)(-644.4, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[2, 5](t)\", 2), var\"v[2, 5](t)\"))\n                                ˍ₋out[14] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[3, 2](t)\")), (*)(160.0, var\"u[3, 4](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(-644.4, var\"u[3, 5](t)\")), (*)((^)(var\"u[3, 5](t)\", 2), var\"v[3, 5](t)\"))\n                                ˍ₋out[15] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[3, 5](t)\")), (*)(160.0, var\"u[4, 2](t)\")), (*)(160.0, var\"u[4, 4](t)\")), (*)(-644.4, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 5](t)\")), (*)((^)(var\"u[4, 5](t)\", 2), var\"v[4, 5](t)\"))\n                                ˍ₋out[16] = (+)((+)((+)((+)((+)((+)(1.0, (*)(160.0, var\"u[2, 5](t)\")), (*)(160.0, var\"u[4, 5](t)\")), (*)(160.0, var\"u[5, 2](t)\")), (*)(160.0, var\"u[5, 4](t)\")), (*)(-644.4, var\"u[5, 5](t)\")), (*)((^)(var\"u[5, 5](t)\", 2), var\"v[5, 5](t)\"))\n                                ˍ₋out[17] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 2](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(-640.0, var\"v[2, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 2](t)\", 2)), var\"v[2, 2](t)\"))\n                                ˍ₋out[18] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 2](t)\", 2)), var\"v[3, 2](t)\"))\n                                ˍ₋out[19] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 2](t)\"), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 2](t)\", 2)), var\"v[4, 2](t)\"))\n                                ˍ₋out[20] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 2](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 2](t)\", 2)), var\"v[5, 2](t)\"))\n                                ˍ₋out[21] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 3](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(-640.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 3](t)\", 2)), var\"v[2, 3](t)\"))[Imgur](https://i.imgur.com/3kQNMI3.gifv)\n                                ˍ₋out[22] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[3, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 3](t)\", 2)), var\"v[3, 3](t)\"))\n                                ˍ₋out[23] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 3](t)\"), (*)(160.0, var\"v[3, 3](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(-640.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 3](t)\", 2)), var\"v[4, 3](t)\"))\n                                ˍ₋out[24] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 3](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 3](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 3](t)\", 2)), var\"v[5, 3](t)\"))\n                                ˍ₋out[25] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 4](t)\"), (*)(160.0, var\"v[2, 3](t)\")), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[2, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 4](t)\", 2)), var\"v[2, 4](t)\"))\n                                ˍ₋out[26] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[3, 3](t)\")), (*)(-640.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 4](t)\", 2)), var\"v[3, 4](t)\"))\n                                ˍ₋out[27] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 4](t)\"), (*)(160.0, var\"v[3, 4](t)\")), (*)(160.0, var\"v[4, 3](t)\")), (*)(-640.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 4](t)\", 2)), var\"v[4, 4](t)\"))\n                                ˍ₋out[28] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 4](t)\"), (*)(160.0, var\"v[2, 4](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 3](t)\")), (*)(-640.0, var\"v[5, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 4](t)\", 2)), var\"v[5, 4](t)\"))\n                                ˍ₋out[29] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[2, 5](t)\"), (*)(160.0, var\"v[2, 2](t)\")), (*)(160.0, var\"v[2, 4](t)\")), (*)(-640.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[2, 5](t)\", 2)), var\"v[2, 5](t)\"))\n                                ˍ₋out[30] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[3, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[3, 2](t)\")), (*)(160.0, var\"v[3, 4](t)\")), (*)(-640.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[3, 5](t)\", 2)), var\"v[3, 5](t)\"))\n                                ˍ₋out[31] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[4, 5](t)\"), (*)(160.0, var\"v[3, 5](t)\")), (*)(160.0, var\"v[4, 2](t)\")), (*)(160.0, var\"v[4, 4](t)\")), (*)(160.0, var\"v[5, 5](t)\")), (*)(-640.0, var\"v[4, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[4, 5](t)\", 2)), var\"v[4, 5](t)\"))\n                                ˍ₋out[32] = (+)((+)((+)((+)((+)((+)((*)(3.4, var\"u[5, 5](t)\"), (*)(160.0, var\"v[2, 5](t)\")), (*)(160.0, var\"v[4, 5](t)\")), (*)(160.0, var\"v[5, 2](t)\")), (*)(160.0, var\"v[5, 4](t)\")), (*)(-640.0, var\"v[5, 5](t)\")), (*)((*)(-1.0, (^)(var\"u[5, 5](t)\", 2)), var\"v[5, 5](t)\"))\n                                nothing\n                            end\n                    end\n                end\n            end)\n    var\"##tgrad#261\" = nothing\n    var\"##jac#262\" = nothing\n    M = UniformScaling{Bool}(true)\n    ODEFunction{true}(var\"##f#260\", jac = var\"##jac#262\", tgrad = var\"##tgrad#261\", mass_matrix = M, jac_prototype = nothing, syms = [Symbol(\"u[2, 2](t)\"), Symbol(\"u[3, 2](t)\"), Symbol(\"u[4, 2](t)\"), Symbol(\"u[5, 2](t)\"), Symbol(\"u[2, 3](t)\"), Symbol(\"u[3, 3](t)\"), Symbol(\"u[4, 3](t)\"), Symbol(\"u[5, 3](t)\"), Symbol(\"u[2, 4](t)\"), Symbol(\"u[3, 4](t)\"), Symbol(\"u[4, 4](t)\"), Symbol(\"u[5, 4](t)\"), Symbol(\"u[2, 5](t)\"), Symbol(\"u[3, 5](t)\"), Symbol(\"u[4, 5](t)\"), Symbol(\"u[5, 5](t)\"), Symbol(\"v[2, 2](t)\"), Symbol(\"v[3, 2](t)\"), Symbol(\"v[4, 2](t)\"), Symbol(\"v[5, 2](t)\"), Symbol(\"v[2, 3](t)\"), Symbol(\"v[3, 3](t)\"), Symbol(\"v[4, 3](t)\"), Symbol(\"v[5, 3](t)\"), Symbol(\"v[2, 4](t)\"), Symbol(\"v[3, 4](t)\"), Symbol(\"v[4, 4](t)\"), Symbol(\"v[5, 4](t)\"), Symbol(\"v[2, 5](t)\"), Symbol(\"v[3, 5](t)\"), Symbol(\"v[4, 5](t)\"), Symbol(\"v[5, 5](t)\")], indepsym = :t)\nend","category":"page"},{"location":"howitworks/#hiw","page":"How it works","title":"How it works","text":"","category":"section"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, namely it's rule matching features to recognize terms which require particular discretizations.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"Given your discretization and PDESystem, we take each independent variable defined on the space to be discretized and create a corresponding range. We then take each dependant variable and create an array of symbolic variables to represent it in its discretized form. ","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"Next, the boundary conditions are discretized, creating an equation for each point on the boundary in terms of the discretized variables, replacing any space derivatives in the direction of the boundary with their upwind finite difference expressions.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"After that, the system of PDEs is discretized, first matching each PDE to each dependant variable by which variable is highest order in each PDE, with precedance given to time derivatives. Then, the PDEs are discretized creating a finite difference equation for each point in their matched dependant variables discrete form, less the number of boundary equations. These equations are removed from around the boundary, so each PDE only has discrete equations on its variable's interior.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"Now we have a system of equations which are either ODEs, linear, or nonlinear equations and an equal number of unknowns. See here for the system that is generated for the Brusselator at low point count. The structure of the system is simplified with ModelingToolkit.structural_simplify, and then either an ODEProblem or NonlinearProblem is returned. Under the hood, the ODEProblem generates a fast semidiscretization, written in julia with RuntimeGeneratedFunctions. See here for an example of the generated code for the Brusselator system at low point count. ","category":"page"},{"location":"#index","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"MethodOfLines.jl is a package for automated finite difference discretization of symbolicaly-defined PDEs in N dimensions.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"It uses symbolic expressions for systems of partial differential equations as defined with ModelingToolkit.jl, and Interval from DomainSets.jl to define the space(time) over which the simulation runs.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"The package's handling is quite general, it is recommended to try out your system of equations and post an issue if you run in to trouble. If you want to solve it, we want to support it.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"See here for a full tutorial, involving the Brusselator equation.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Allowable terms in the system include, but are not limited to","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Advection\nDiffusion\nReaction\nNonlinear Diffusion\nSpherical laplacian\nAny Julia function of the symbolic parameters/dependant variables and other parameters in the environment that's defined on the whole domain.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Boundary conditions include, but are not limited to:","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"Dirichlet\nNeumann (can also include time derivative)\nRobin (can also include time derivative)\nPeriodic\nAny function, subject to the assumptions below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"At the moment the centered difference, upwind difference, nonlinear laplacian and spherical laplacian schemes are implemented. If you know of a scheme with better stability or accuracy in any specific case, please post an issue with a link to a paper.","category":"page"},{"location":"#limitations","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"Known Limitations","text":"","category":"section"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"At the moment the package is able to discretize almost any system, with some assumptions listed below","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"That the grid is cartesian.\nThat the equation is first order in time.\nIntergral equations are not supported.\nThat dependant variables always have the same argument signature, except in BCs.\nThat periodic boundary conditions are of the simple form u(t, x_min) ~ u(t, x_max), or the same with lhs and rhs reversed. Note that this generalises to higher dimensions.\nThat boundary conditions do not contain references to derivatives which are not in the direction of the boundary, except in time.\nThat initial conditions are of the form u(...) ~ ..., and don't reference the initial time derivative.\nThat simple derivative terms are purely of a dependant variable, for example Dx(u(t,x,y)) is allowed but Dx(u(t,x,y)*v(t,x,y)), Dx(u(t,x)+1) or Dx(f(u(t,x))) are not. As a workaround please expand such terms with the product/chain rules and use the linearity of the derivative operator, or define a new dependant variable by adding an equation for it like eqs = [Differential(x)(w(t,x))~ ... , w(t,x) ~ v(t,x)*u(t,x)]. An exception to this is if the differential is a nonlinear or spherical laplacian, in which case only the innermost argument should be wrapped.","category":"page"},{"location":"","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","text":"If any of these limitations are a problem for you please post an issue and we will prioritize removing them. If you discover a limitation that isn't listed here, pleae post an issue with example code.","category":"page"},{"location":"#If-you-have-any-usage-questions-or-feature-requests,-please-post-an-issue","page":"MethodOfLines.jl: Automated Finite Difference for Phyiscs-Informed Learning","title":"If you have any usage questions or feature requests, please post an issue","text":"","category":"section"},{"location":"boundary_conditions/#[Boundary-Conditions](@ref-bcs)","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"What follows is a set of allowable boundary conditions, please note that this is not exhaustive - try your condition and see if it works, the handling is quite general. If it doesn't please post an issue and we'll try to support it. At the moment boundary conditions have to be supplied at the edge of the domain, but there are plans to support conditions embedded in the domain.","category":"page"},{"location":"boundary_conditions/#Definitions","page":"Boundary Conditions","title":"Definitions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using ModelingToolkit, MethodOfLines, Domainsets\n\n@parameters x y t\n@variables u(..) v(..)\nDt = Differential(t)\nDx = Differential(x)\nDy = Differential(y)\nDxx = Differential(x)^2\nDyy = Differential(y)^2\n\nx_min = y_min = 0.0\n\nx_max = y_max = 1.0","category":"page"},{"location":"boundary_conditions/#Dirichlet","page":"Boundary Conditions","title":"Dirichlet","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, 0, y) ~ 1.0","category":"page"},{"location":"boundary_conditions/#Time-dependant","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, 0., y) ~ x_min*y+ 0.5t","category":"page"},{"location":"boundary_conditions/#Julia-function","page":"Boundary Conditions","title":"Julia function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, y_max) ~ sin(x)","category":"page"},{"location":"boundary_conditions/#User-defined-function","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"alpha = 9\n\nf(t,x,y) = x*y - t\n\nfunction g(x,y) \n    z = sin(x*y)+cos(y)\n    # Note that symbolic conditionals require the use of IfElse.ifelse\n    return IfElse.ifelse(z > 0, x, 0.0)\nend\n\nu(t,x,y_min) ~ f(t,x,y_min) + alpha/g(x,y_min)","category":"page"},{"location":"boundary_conditions/#Neumann/Robin","page":"Boundary Conditions","title":"Neumann/Robin","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x_min, y) ~ 2. * Dx(v(t, x_min, y))","category":"page"},{"location":"boundary_conditions/#Time-dependant-2","page":"Boundary Conditions","title":"Time dependant","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ x_min*Dy(v(t,x_min,y)) + 0.5t","category":"page"},{"location":"boundary_conditions/#Higher-order","page":"Boundary Conditions","title":"Higher order","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"v(t, x, 1.0) ~ sin(x) + Dyy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Time-derivative","page":"Boundary Conditions","title":"Time derivative","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Dt(u(t, x_min, y)) ~ 0.2","category":"page"},{"location":"boundary_conditions/#User-defined-function-2","page":"Boundary Conditions","title":"User defined function","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"function f(u, v)\n    (u + Dyy(v) - Dy(u))/(1 + v)\nend\n\nDyy(u(t, x, y_min)) ~ f(u(t, x, y_min), v(t, x, y_min)) + 1","category":"page"},{"location":"boundary_conditions/#lhs","page":"Boundary Conditions","title":"0 lhs","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"0 ~ u(t, x, y_max) - Dy(v(t, x, y_max))","category":"page"},{"location":"boundary_conditions/#Periodic","page":"Boundary Conditions","title":"Periodic","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary Conditions","title":"Boundary Conditions","text":"u(t, x_min, y) ~ u(t, x_max, y)\n\nv(t, x, y_max) ~ u(t, x_max, y)","category":"page"},{"location":"devnotes/#Notes-for-developers","page":"Notes for developers: Implement a scheme","title":"Notes for developers","text":"","category":"section"},{"location":"devnotes/#Getting-started","page":"Notes for developers: Implement a scheme","title":"Getting started","text":"","category":"section"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"First, fork the repo and clone it locally.","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"Then, type in the REPL","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"julia>] dev /path/to/your/repo\njulia>] activate MethodOfLines","category":"page"},{"location":"devnotes/#Overview","page":"Notes for developers: Implement a scheme","title":"Overview","text":"","category":"section"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"MethodOfLines.jl makes heavy use of Symbolics.jl and SymbolicUtils.jl, especially the replacement rules from the latter.","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"Take a look at src/discretization/MOL_discretization.jl to get a high level overview of how the discretization works. A more consise description can be found here. Feel free to post an issue if you would like help understanding anything, or want to know developer opinions on the best way to go about implementing something.","category":"page"},{"location":"devnotes/#Adding-new-finite-difference-schemes","page":"Notes for developers: Implement a scheme","title":"Adding new finite difference schemes","text":"","category":"section"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"If you know of a finite difference scheme which is better than what is currently implemented, please first post an issue with a link to a paper.","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"A replacement rule is generated for each term which has a more specific higher stability/accuracy finite difference scheme than the general central difference, which represents a base case.","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"Take a look at src/discretization/generate_finite_difference_rules.jl to see how the replacement rules are generated. Note that the order that the rules are applied is important; there may be schemes that are applied first that are special cases of more general rules, for example the sphrical laplacian is a special case of the nonlinear lalacian.","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"First terms are split, isolating particular cases. Then, rules are generated and applied. Take a look at the docs for symbolic utils to get an idea of how these work. ","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"Identify a rule which will match your case, then write a function that will handle how to apply that scheme for each index in the interior, for each combination of independant and dependant variables. ","category":"page"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"Initially, don't worry if your scheme is only implemented for specific approximation orders, it is sufficient just to warn when the requested approximation order does not match that supplied by the scheme. We can work in future pull requests to generalize the scheme to higher approximation orders, where possible.","category":"page"},{"location":"devnotes/#Inspecting-generated-code","page":"Notes for developers: Implement a scheme","title":"Inspecting generated code","text":"","category":"section"},{"location":"devnotes/","page":"Notes for developers: Implement a scheme","title":"Notes for developers: Implement a scheme","text":"To get the generated code for your system, use code = ODEFunctionExpr(prob), or MethodOfLines.generate_code(pdesys, discretization, \"my_generated_code_filename.jl\"), which will create a file called my_generated_code_filename.jl in pwd(). This can be useful to find errors in the discretization, but note that it is not recommended to use this code directly, calling solve(prob, AppropriateSolver()) will handle this for you.","category":"page"}]
}
