<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning · MethodOfLines.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/MethodOfLines/stable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="MethodOfLines.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>MethodOfLines.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Contributing"><span>Contributing</span></a></li><li><a class="tocitem" href="#limitations"><span>Known Limitations</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/brusselator/">Tutorial</a></li><li><a class="tocitem" href="tutorials/heat/">Solving the Heat Equation</a></li><li><a class="tocitem" href="tutorials/params/">Adding parameters</a></li><li><a class="tocitem" href="tutorials/heatss/">Steady State Heat Equation - No Time Dependance - NonlinearProblem</a></li><li><a class="tocitem" href="tutorials/sispde/">Steady state of SIS (suspected-infected-suspected) reaction-diffusion  model</a></li><li><a class="tocitem" href="tutorials/icbc_sampled/">Initial and Boundary Conditions with sampled/measured Data</a></li></ul></li><li><a class="tocitem" href="MOLFiniteDifference/">MOLFiniteDifference</a></li><li><a class="tocitem" href="solutions/">Solution Interface - PDESolutions</a></li><li><a class="tocitem" href="get_grid/">Grid and Solution Retrieval - Deprecated</a></li><li><a class="tocitem" href="boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="advection_schemes/">Advection Schemes</a></li><li><a class="tocitem" href="nonuniform/">Non-Uniform Rectilinear Grids</a></li><li><a class="tocitem" href="curvilinear_grids/">Curvilinear Grids</a></li><li><a class="tocitem" href="howitworks/">How it Works</a></li><li><a class="tocitem" href="devnotes/">Notes for Developers: Implement a Scheme</a></li><li><span class="tocitem">Generated Examples</span><ul><li><a class="tocitem" href="generated/bruss_code/">Generated Code for the Brusselator Equation</a></li><li><a class="tocitem" href="generated/bruss_ode_eqs/">Generated ODE system for the Brusselator Equation</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="api/discretization/">Discretization</a></li><li><a class="tocitem" href="api/utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/MethodOfLines.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="index"><a class="docs-heading-anchor" href="#index">MethodOfLines.jl: Automated Finite Difference for Physics-Informed Learning</a><a id="index-1"></a><a class="docs-heading-anchor-permalink" href="#index" title="Permalink"></a></h1><p><a href="https://github.com/SciML/MethodOfLines.jl">MethodOfLines.jl</a> is a Julia package for automated finite difference discretization of symbolicaly-defined PDEs in N dimensions.</p><p>It uses symbolic expressions for systems of partial differential equations as defined with <code>ModelingToolkit.jl</code>, and <code>Interval</code> from <code>DomainSets.jl</code> to define the space(time) over which the simulation runs.</p><p>It is a SciML &quot;Discretizer&quot; package, a class of packages which export the methods:</p><ul><li><code>discretize(sys::PDESystem, disc::D) where {D &lt;: AbstractDiscretization}</code>, which returns an <code>AbstractSciMLProblem</code> to be solved with the ecosystem&#39;s solvers.</li><li><code>symbolic_discretize(sys::PDESystem, disc::D) where {D &lt;: AbstractDiscretization}</code>, which returns an <code>AbstractSciMLSystem</code> from <code>ModelingToolkit.jl</code>.</li></ul><p>A Discretizer also optionally provides automatic solution wrapping, for easing the retrieval of shaped portions of the solution, and multi dimensional interpolations. This feature is provided by <code>MethodOfLines.jl</code>, see the <a href="solutions/#sol">solution interface</a> page for more information.</p><p>The <code>AbstractDiscretization</code> that <code>MethodOfLines.jl</code> provides is the <a href="MOLFiniteDifference/#molfd"><code>MOLFiniteDifference</code></a>, see its documentation for full information about interface options.</p><p>The package&#39;s handling is quite general, it is recommended to try out your system of equations and post an issue if you run in to trouble. If you want to solve it, we want to support it.</p><p>Issues with questions on usage are also welcome as they help us improve the docs.</p><p>See <a href="tutorials/brusselator/#brusselator">here</a> for a full tutorial, involving the Brusselator equation.</p><p>Allowable terms in the system include, but are not limited to</p><ul><li>Advection</li><li>Diffusion</li><li>Reaction</li><li>Nonlinear Diffusion</li><li>Spherical laplacian</li><li>Any Julia function of the symbolic parameters/dependant variables and other parameters in the environment that&#39;s defined on the whole domain. Note that more complicated functions may require registration with <code>@register</code>, see the <a href="https://docs.sciml.ai/ModelingToolkit/stable/basics/Validation/#User-Defined-Registered-Functions-and-Types">ModelingToolkit.jl docs</a>.</li></ul><p>Boundary conditions include, but are not limited to:</p><ul><li>Dirichlet</li><li>Neumann (can also include time derivative)</li><li>Robin (can also include time derivative)</li><li>Periodic</li><li>Any function, subject to the assumptions below</li></ul><p>At the moment the centered difference, upwind difference, nonlinear laplacian and spherical laplacian schemes are implemented. If you know of a scheme with better stability or accuracy in any specific case, please post an issue with a link to a paper.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>Assuming that you already have Julia correctly installed, it suffices to import Optimization.jl in the standard way:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;MethodOfLines&quot;)</code></pre><p>The packages relevant to the core functionality of Optimization.jl will be imported accordingly and, in most cases, you do not have to worry about the manual installation of dependencies. However, you will need to add the specific optimizer packages.</p><h2 id="Contributing"><a class="docs-heading-anchor" href="#Contributing">Contributing</a><a id="Contributing-1"></a><a class="docs-heading-anchor-permalink" href="#Contributing" title="Permalink"></a></h2><ul><li>Please refer to the <a href="https://github.com/SciML/ColPrac/blob/master/README.md">SciML ColPrac: Contributor&#39;s Guide on Collaborative Practices for Community Packages</a> for guidance on PRs, issues, and other matters relating to contributing to SciML.</li><li>See the <a href="https://github.com/SciML/SciMLStyle">SciML Style Guide</a> for common coding practices and other style decisions.</li><li>There are a few community forums:<ul><li>The #diffeq-bridged and #sciml-bridged channels in the <a href="https://julialang.org/slack/">Julia Slack</a></li><li>The #diffeq-bridged and #sciml-bridged channels in the <a href="https://julialang.zulipchat.com/#narrow/stream/279055-sciml-bridged">Julia Zulip</a></li><li>On the <a href="https://discourse.julialang.org">Julia Discourse forums</a></li><li>See also <a href="https://sciml.ai/community/">SciML Community page</a></li></ul></li></ul><h2 id="limitations"><a class="docs-heading-anchor" href="#limitations">Known Limitations</a><a id="limitations-1"></a><a class="docs-heading-anchor-permalink" href="#limitations" title="Permalink"></a></h2><p>At the moment the package is able to discretize almost any system, with some assumptions listed below</p><ul><li>That the grid is cartesian.</li><li>Boundary conditions in time are supplied as initial conditions, not at the end of the simulation interal. If your system requires a final condition, please use a change of variables to rectify this. This is unlikely to change due to upstream constraints.</li><li>Intergral equations are not supported.</li><li>That dependant variables always have the same argument signature, except in BCs.</li><li>That periodic boundary conditions are of the simple form <code>u(t, x_min) ~ u(t, x_max)</code>, or the same with lhs and rhs reversed. Note that this generalises to higher dimensions. Please note that if you want to use a periodic condition on a dimension with WENO schemes, please use a periodic condition on all variables in that dimension.</li><li>That boundary conditions do not contain references to derivatives which are not in the direction of the boundary, except in time.</li><li>That odd order derivatives do not multiply or divide each other. A workaround is to wrap all but one derivative per term in an auxiliary variable, such as <code>dxu(x, t) ~ Differential(x)(u(x, t))</code>. The performance hit from auxiliary variables should be negligable due to a structural simplification step.</li><li>That the WENO scheme must be used when there are mixed derivatives.</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="tutorials/brusselator/">Tutorial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 1 November 2022 15:14">Tuesday 1 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
